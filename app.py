# -*- coding: utf-8 -*-
"""Дом.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HwFCoRy7U-l-chPfiy1alK3CTcukf9Gw
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("selling_apartments.csv")
pd.set_option('display.max_columns', None)
print(df)

"""# Обработка данных"""

del df['published']
del df['updated']
del df['agencyName']
del df['enterances']
del df['build_year']
del df['build_serias']
del df['max_levels']
del df['min_levels']
del df['build_type']
del df['areaRating']

df = df[df['city'] == 'Москва']
df[['current_level', 'all_level']] = df['level'].str.split('/', expand=True)
df['current_level'] = pd.to_numeric(df['current_level'], errors='coerce')
df['all_level'] = pd.to_numeric(df['all_level'], errors='coerce')

del df['level']

del df['city']

df

missing_values = df.isnull().sum()
print(missing_values)

df['kitchen_area'] = df.groupby('rooms')['kitchen_area'].transform(lambda x: x.fillna(x.median()))
df['living_area'] = df.groupby('rooms')['living_area'].transform(lambda x: x.fillna(x.median()))

df['material'].fillna(df['material'].mode()[0], inplace=True)
df['all_level'].fillna(df['all_level'].mode()[0], inplace=True)

df['all_level'] = df['all_level'].astype('int64')

mode_value = df.loc[df['object_type'] != '0', 'object_type'].mode()[0]
df['object_type'] = df['object_type'].replace('0', mode_value)

df = df.drop(df[df['build_overlap'] == '0'].index)
df = df.drop(df[df['rubbish_chute'] == '0'].index)

values_to_replace = ['0', 'Не заполнено', 'Специализированный жилищный фонд','Жилой дом блокированной застройки']
df['type'] = df['type'].replace(values_to_replace, 'Иное')

df = df[(df['area'] > 0) | (df['area'].isna())]

df.loc[(df['rooms'] == 0) & (df['area'] > 0), 'rooms'] = 1

unique_values = df['build_overlap'].unique()
print(unique_values)

counts = df['gas'].value_counts()
print(counts)

df["gas"] = df["gas"].replace("0", "Нет")

heating_replacement = {
    'Индивидуальный тепловой пункт (ИТП)': 'ИТП',
    'Автономная котельная (крышная, встроенно-пристроенная)': 'Автономная котельная',
    'Квартирное отопление (квартирный котел)': 'Квартирное',
    'Печное': 'Без отопления',
    '0': 'Центральное',
    'Нет': 'Без отопления'
}


df['heating'] = df['heating'].replace(heating_replacement)
print(df['heating'].value_counts(dropna=False))

replacement_dict = {
    'Смешанные': 'Другие',
    'Деревянные': 'Другие',
    'Железобетонная панель': 'Железобетон',
    'Каменные, кирпичные': 'Кирпич',
    '0': 'Железобетон',
    'Не заполнено': 'Железобетон'
}


df['build_walls'] = df['build_walls'].replace(replacement_dict)

print(df['build_walls'].value_counts())

print(df['build_walls'].value_counts())
print(df['object_type'].value_counts())
print(df['type'].value_counts())
print(df['material'].value_counts())
print(df['rubbish_chute'].value_counts())
print(df['build_overlap'].value_counts())
print(df['build_walls'].value_counts())
print(df['heating'].value_counts())
print(df['gas'].value_counts())
print(df['build_oldest'].value_counts())

print(df['heating'].value_counts())

df['material'] = df['material'].replace('Дерево', 'Другие')
df['material'] = df['material'].replace('Блоки', 'Другие')

df['heating'] = df['heating'].replace('Квартирное', 'Центральное')

numeric_cols = ['kitchen_area', 'living_area', 'area', 'price_by_meter', 'price', 'remoute_from_center']

# 1. Описательная статистика
print(df[numeric_cols].describe())

# 2. Визуализация
plt.figure(figsize=(15, 8))
for i, col in enumerate(numeric_cols, 1):
    plt.subplot(2, 3, i)
    sns.boxplot(y=df[col])
    plt.title(col)
plt.tight_layout()
plt.show()

# 3. Метод межквартильного размаха (IQR)
for col in numeric_cols:
    Q1 = df[col].quantile(0.25)
    Q3 = df[col].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = df[(df[col] < lower_bound) | (df[col] > upper_bound)]
    print(f"\nВыбросы в {col}: {len(outliers)} записей")

def treat_outliers(df, column, method='remove', factor=1.5):
    Q1 = df[column].quantile(0.25)
    Q3 = df[column].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - factor * IQR
    upper_bound = Q3 + factor * IQR

    if method == 'remove':
        return df[(df[column] >= lower_bound) & (df[column] <= upper_bound)]
    elif method == 'cap':
        df[column] = np.where(df[column] < lower_bound, lower_bound,
                             np.where(df[column] > upper_bound, upper_bound, df[column]))
        return df
    elif method == 'transform':
        df[column] = np.log1p(df[column])
        return df
    return df

df = treat_outliers(df, 'kitchen_area', method='cap')
df = treat_outliers(df, 'living_area', method='cap')
df = treat_outliers(df, 'area', method='cap')


df = treat_outliers(df, 'price_by_meter', method='remove')
df = treat_outliers(df, 'price', method='remove')


df = treat_outliers(df, 'remoute_from_center', method='transform')

import numpy as np
import pandas as pd

def remove_outliers_iqr(df, columns, factor=1.5):
    clean_df = df.copy()
    for col in columns:
        Q1 = clean_df[col].quantile(0.25)
        Q3 = clean_df[col].quantile(0.75)
        IQR = Q3 - Q1
        lower_bound = Q1 - factor * IQR
        upper_bound = Q3 + factor * IQR
        clean_df = clean_df[(clean_df[col] >= lower_bound) & (clean_df[col] <= upper_bound)]
    return clean_df

#Очистка
numeric_cols = ['kitchen_area', 'living_area', 'area',
               'price_by_meter', 'price', 'remoute_from_center']

# Удаляьть выбросы
df_clean = remove_outliers_iqr(df, numeric_cols)

# Дополнительные логические проверки
df_clean = df_clean[
    (df_clean['kitchen_area'] + df_clean['living_area'] <= df_clean['area'] * 1.1) &
    (df_clean['current_level'] <= df_clean['all_level']) &
    (df_clean['price'] > 0) &
    (df_clean['area'] > 10)
]

# Анализ результатов
print(f"Было записей: {len(df)}")
print(f"Стало записей: {len(df_clean)}")
print(f"Удалено записей: {len(df) - len(df_clean)} ({(len(df)-len(df_clean))/len(df)*100:.1f}%)")

# Оставшиеся выбросы
from scipy import stats
for col in numeric_cols:
    z_scores = np.abs(stats.zscore(df_clean[col]))
    outliers = len(np.where(z_scores > 3)[0])
    print(f"{col}: {outliers} выбросов ({outliers/len(df_clean)*100:.1f}%)")

full_duplicates = df[df.duplicated(keep=False)]  # keep=False помечает все дубли
print(f"Полных дубликатов: {len(full_duplicates)}")
print("Примеры полных дубликатов:")
print(full_duplicates.sort_values(by=df.columns.tolist()).head())

df.drop_duplicates(inplace=True)

"""# Визуализация данных"""

print(df.describe())

"""Распределение цен"""

plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x="area", y="price", hue="rooms", size="rooms")
plt.title("Зависимость цены от площади")
plt.xlabel("Площадь (м²)")
plt.ylabel("Цена (руб)")
plt.grid(True)
plt.show()

plt.figure(figsize=(10, 6))
sns.barplot(data=df, x="rooms", y="price_by_meter", palette="viridis")
plt.title("Средняя цена за м² по количеству комнат")
plt.xlabel("Количество комнат")
plt.ylabel("Цена за м² (руб)")
plt.show()

import plotly.express as px

fig = px.scatter_mapbox(
    df,
    lat="latitude",
    lon="longitude",
    color="price",
    size="area",
    hover_name="type",
    mapbox_style="open-street-map",
    zoom=10,
    title="Карта цен на недвижимость"
)
fig.show()

fig = px.pie(
    df,
    names="material",
    values="price",
    title="Доля материалов домов"
)
fig.show()

plt.figure(figsize=(10, 6))
sns.violinplot(data=df, x='rubbish_chute', y='price', palette='Set2')
plt.title('Влияние мусоропровода на цену')
plt.xlabel('Наличие мусоропровода')
plt.ylabel('Цена (руб)')
plt.show()

"""# Анализ"""

from sklearn.preprocessing import LabelEncoder


cat_cols = df.select_dtypes(include=['object']).columns

for col in cat_cols:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])

    print(f"Кодировка для {col}:")
    print(dict(zip(le.classes_, le.transform(le.classes_))))
    print()

print("\nРезультат:")
print(df)

plt.figure(figsize=(10, 6))
numeric_df = df.select_dtypes(include=["int64", "float64"])
corr = numeric_df.corr()
sns.heatmap(corr, annot=True, cmap="coolwarm", fmt=".2f")
plt.title("Корреляция числовых признаков")
plt.show()

"""area (0.78): Увеличение площади на 1 м² ассоциировано с ростом цены на ~78%

living_area (0.72): Жилая площадь также сильно влияет на стоимость

kitchen_area (0.64): Размер кухни значим, но менее чем общая площадь


remoute_from_center (-0.26): Удаление от центра снижает цену

build_oldest (-0.19): Старые постройки дешевле

Линейная регрессия
"""

import numpy as np
import pandas as pd
import statsmodels.api as sm
from statsmodels.stats.outliers_influence import variance_inflation_factor
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt


df_clean = df.drop(['living_area', 'heating', 'rubbish_chute', 'latitude', 'longitude', 'price_by_meter'], axis=1)


df_clean['log_price'] = np.log1p(df_clean['price'])
scaler = StandardScaler()
num_cols = ['area', 'kitchen_area', 'remoute_from_center']
df_clean[num_cols] = scaler.fit_transform(df_clean[num_cols])


X = df_clean.drop(['price', 'log_price'], axis=1)
y = df_clean['log_price']


vif_data = pd.DataFrame()
vif_data["feature"] = X.columns
vif_data["VIF"] = [variance_inflation_factor(X.values, i) for i in range(X.shape[1])]
high_vif = vif_data[vif_data["VIF"] > 5].feature.tolist()
X_reduced = X.drop(high_vif, axis=1)


X_final = sm.add_constant(X_reduced)
model = sm.OLS(y, X_final).fit()


print(model.summary())

"""R²=0.602 (модель объясняет 60.2% вариаций цен)

 Все коэффициенты имеют p-value < 0.001

Мультиколлинеарность: Cond. No.=39.4 (приемлемый уровень)


kitchen_area: +0.422 (↑ площади кухни на 1 величину → +42.2% к цене)

current_level: +0.0175 (каждый этаж → +1.75% к цене)

gas: +0.032 (газификация → +3.2% к стоимости)

remoute_from_center: -0.1796 (удаление от центра → -17.96%)

object_type: -0.4276 (специфические типы объектов → -42.76%)

build_walls: -0.0129 (определенные материалы стен → -1.29%)

Кластеризация
"""

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt


features = ['price', 'area', 'price_by_meter', 'kitchen_area', 'remoute_from_center']
X = df[features]


from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)


wcss = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(X_scaled)
    wcss.append(kmeans.inertia_)


plt.figure(figsize=(10,6))
plt.plot(range(1, 11), wcss, marker='o')
plt.title('Метод локтя')
plt.xlabel('Количество кластеров')
plt.ylabel('WCSS (Within-Cluster Sum of Squares)')
plt.axvline(x=3, color='r', linestyle='--')
plt.show()

"""Оптимальное количество кластеров - 3"""

import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans


cluster_features = ['price', 'area', 'price_by_meter', 'kitchen_area', 'remoute_from_center']


scaler = StandardScaler()
scaled_data = scaler.fit_transform(df[cluster_features])


kmeans = KMeans(n_clusters=3, random_state=42)
df['price_cluster'] = kmeans.fit_predict(scaled_data)


plt.figure(figsize=(10,6))
sns.countplot(x='price_cluster', data=df)
plt.title('Распределение объектов по кластерам (3 кластера)')
plt.show()


cluster_stats = df.groupby('price_cluster')[cluster_features].mean()
print("Средние значения по кластерам:")
print(cluster_stats)


plt.figure(figsize=(12,8))
sns.scatterplot(x='longitude', y='latitude', hue='price_cluster',
                data=df, palette='viridis', alpha=0.6)
plt.title('Географическое распределение кластеров (3 кластера)')
plt.show()

"""***Кластер 0 (Средний сегмент):***


Средняя цена: 13.24 млн руб

Площадь: 55.7 м²

Цена за м²: 242 тыс. руб

Кухня: 9.6 м²

Удаленность от центра: 2.86



***Кластер 1 (Премиум сегмент)***

Средняя цена: 20.96 млн руб (+58% к кластеру 0)


Площадь: 61.8 м² (+11%)

Цена за м²: 349 тыс. руб (+44%)

Кухня: 10.7 м² (+11%)

Удаленность: 2.17 (ближе к центру)



***Кластер 2 (Эконом сегмент)***

Средняя цена: 6.11 млн руб (в 3.5 раза дешевле кластера 1)

Площадь: 21.7 м² (компактные)

Цена за м²: 283 тыс. руб

Кухня: 3.6 м² (очень маленькие)

# **Факторный анализ**
"""

!pip install factor-analyzer
from sklearn.preprocessing import StandardScaler
from factor_analyzer import FactorAnalyzer
from factor_analyzer.factor_analyzer import calculate_bartlett_sphericity, calculate_kmo
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt


numeric_cols = ['rooms', 'kitchen_area', 'living_area', 'area',
                'price_by_meter', 'price', 'remoute_from_center',
                'current_level', 'all_level']


scaler = StandardScaler()
scaled_data = scaler.fit_transform(df[numeric_cols].dropna())



fa = FactorAnalyzer(rotation=None, impute="drop")
fa.fit(scaled_data)

# График каменистой осыпи
ev, _ = fa.get_eigenvalues()
plt.figure(figsize=(10,6))
plt.scatter(range(1, scaled_data.shape[1]+1), ev)
plt.plot(range(1, scaled_data.shape[1]+1), ev)
plt.title('График каменистой осыпи')
plt.xlabel('Факторы')
plt.ylabel('Собственное значение')
plt.axhline(y=1, color='r', linestyle='--')
plt.show()

# Выбор числа факторов
n_factors = sum(ev > 1)
print(f"\nРекомендуемое число факторов: {n_factors}")

# Варимакс метод вращения
fa = FactorAnalyzer(n_factors=n_factors, rotation="varimax")
fa.fit(scaled_data)

# ФН
loadings = pd.DataFrame(
    fa.loadings_,
    index=numeric_cols,
    columns=[f"Factor_{i}" for i in range(1, n_factors+1)]
)


plt.figure(figsize=(12,6))
sns.heatmap(loadings, annot=True, cmap='coolwarm', center=0, fmt=".2f")
plt.title('Матрица факторных нагрузок (вращение Varimax)')
plt.show()



for i in range(n_factors):
    print(f"\nФактор {i+1}:")
    print(loadings[f'Factor_{i+1}'].sort_values(ascending=False).head(3))

# Дисперсия, объясненняюща каждый фактор
variance = fa.get_factor_variance()

variance_df = pd.DataFrame({
    'Фактор': [f'Factor_{i+1}' for i in range(n_factors)],
    'Общая дисперсия': variance[0],
    'Доля дисперсии': variance[1],
    'Накопленная доля': variance[2]
})

print(variance_df)

"""Фактор 1: "Размер жилья" 39.2% дисперсии

living_area (0.955) - жилая площадь

area (0.931) - общая площадь

rooms (0.918) - количество комнат


Этот фактор отражает физический размер недвижимости.

======================================================================


Фактор 2: "Этажность и планировка" 20.2% дисперсии

all_level (0.772) - всего этажей в доме


current_level (0.705) - текущий этаж

kitchen_area (0.610) - площадь кухни


Характеризует вертикальную позицию объекта и особенности планировки.

======================================================================

Фактор 3: "Ценовая политика" 17.3% дисперсии


price_by_meter (0.941) - цена за кв.м


price (0.416) - общая цена

current_level (0.009) - незначимо

Отражает ценовую стратегию с упором на стоимость квадратного метра.

"""

# Деревья решений

from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import classification_report, accuracy_score

# Создаем целевую переменную для классификации (ценовые категории)
price_categories = pd.cut(df_regression['price'],
                         bins=3,
                         labels=['Дешевый', 'Средний', 'Дорогой'])

X_class = df_regression.drop(['price_by_meter', 'price'], axis=1)
y_class = price_categories

# Разделяем данные
X_train_cl, X_test_cl, y_train_cl, y_test_cl = train_test_split(
    X_class, y_class, test_size=0.2, random_state=42, stratify=y_class
)

# Дерево решений
dt_model = DecisionTreeClassifier(max_depth=5, random_state=42)
dt_model.fit(X_train_cl, y_train_cl)
y_pred_dt = dt_model.predict(X_test_cl)

print("Дерево решений (классификация):")
print(f"Точность: {accuracy_score(y_test_cl, y_pred_dt):.4f}")
print("Отчет по классификации:")
print(classification_report(y_test_cl, y_pred_dt))


# KNN


from sklearn.neighbors import KNeighborsClassifier
from sklearn.preprocessing import StandardScaler

# Масштабируем данные для KNN
scaler_knn = StandardScaler()
X_train_knn = scaler_knn.fit_transform(X_train_cl)
X_test_knn = scaler_knn.transform(X_test_cl)

# KNN классификатор
knn_model = KNeighborsClassifier(n_neighbors=5)
knn_model.fit(X_train_knn, y_train_cl)
y_pred_knn = knn_model.predict(X_test_knn)

print("K-ближайших соседей (KNN):")
print(f"Точность: {accuracy_score(y_test_cl, y_pred_knn):.4f}")
print("Отчет по классификации:")
print(classification_report(y_test_cl, y_pred_knn))


# Нейронка


from sklearn.neural_network import MLPRegressor, MLPClassifier
from sklearn.metrics import mean_absolute_error

# Нейронная сеть для регрессии
nn_regressor = MLPRegressor(
    hidden_layer_sizes=(100, 50),
    activation='relu',
    solver='adam',
    max_iter=1000,
    random_state=42
)

nn_regressor.fit(X_train_scaled, y_train)
y_pred_nn = nn_regressor.predict(X_test_scaled)

mse_nn = mean_squared_error(y_test, y_pred_nn)
r2_nn = r2_score(y_test, y_pred_nn)
mae_nn = mean_absolute_error(y_test, y_pred_nn)

print("Нейронная сеть (регрессия):")
print(f"MSE: {mse_nn:.2f}")
print(f"R²: {r2_nn:.4f}")
print(f"MAE: {mae_nn:.2f}")

# Нейронная сеть для классификации
nn_classifier = MLPClassifier(
    hidden_layer_sizes=(100, 50),
    activation='relu',
    solver='adam',
    max_iter=1000,
    random_state=42
)

nn_classifier.fit(X_train_knn, y_train_cl)
y_pred_nn_cl = nn_classifier.predict(X_test_knn)

print("\nНейронная сеть (классификация):")
print(f"Точность: {accuracy_score(y_test_cl, y_pred_nn_cl):.4f}")
print("Отчет по классификации:")
print(classification_report(y_test_cl, y_pred_nn_cl))